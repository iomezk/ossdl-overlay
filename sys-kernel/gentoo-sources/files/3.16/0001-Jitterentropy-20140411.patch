From ccbef760d4e789d1009b503d2214ddd3292ae7b4 Mon Sep 17 00:00:00 2001
From: W-Mark Kubacki <wmark@hurrikane.de>
Date: Mon, 22 Sep 2014 18:41:46 +0200
Subject: [PATCH 1/4] Jitterentropy 20140411

---
 drivers/char/Makefile                    |   3 +-
 drivers/char/jitterentropy-base-kernel.h |  98 +++++
 drivers/char/jitterentropy-base.c        | 731 +++++++++++++++++++++++++++++++
 drivers/char/jitterentropy-dbg.c         | 662 ++++++++++++++++++++++++++++
 drivers/char/jitterentropy-dbg.h         |  50 +++
 drivers/char/jitterentropy-drng.c        | 372 ++++++++++++++++
 drivers/char/jitterentropy-drng.h        | 120 +++++
 drivers/char/jitterentropy-kcapi.c       | 174 ++++++++
 drivers/char/jitterentropy-kcapi.h       |  50 +++
 drivers/char/jitterentropy-stat.c        | 133 ++++++
 drivers/char/jitterentropy.h             | 174 ++++++++
 drivers/char/random.c                    | 112 ++++-
 12 files changed, 2677 insertions(+), 2 deletions(-)
 create mode 100644 drivers/char/jitterentropy-base-kernel.h
 create mode 100644 drivers/char/jitterentropy-base.c
 create mode 100644 drivers/char/jitterentropy-dbg.c
 create mode 100644 drivers/char/jitterentropy-dbg.h
 create mode 100644 drivers/char/jitterentropy-drng.c
 create mode 100644 drivers/char/jitterentropy-drng.h
 create mode 100644 drivers/char/jitterentropy-kcapi.c
 create mode 100644 drivers/char/jitterentropy-kcapi.h
 create mode 100644 drivers/char/jitterentropy-stat.c
 create mode 100644 drivers/char/jitterentropy.h

diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 7bff00b..007bee4 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -2,7 +2,8 @@
 # Makefile for the kernel character device drivers.
 #
 
-obj-y				+= mem.o random.o
+obj-y				+= mem.o random.o jitterentropy-base.o
+CFLAGS_jitterentropy-base.o	= -O0
 obj-$(CONFIG_TTY_PRINTK)	+= ttyprintk.o
 obj-y				+= misc.o
 obj-$(CONFIG_ATARI_DSP56K)	+= dsp56k.o
diff --git a/drivers/char/jitterentropy-base-kernel.h b/drivers/char/jitterentropy-base-kernel.h
new file mode 100644
index 0000000..e913e64
--- /dev/null
+++ b/drivers/char/jitterentropy-base-kernel.h
@@ -0,0 +1,98 @@
+/*
+ * Non-physical true random number generator based on timing jitter.
+ *
+ * Copyright Stephan Mueller <smueller@chronox.de>, 2013
+ *
+ * License
+ * =======
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU General Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
+ * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+
+#ifndef _JITTERENTROPY_BASE_KERNEL_H
+#define _JITTERENTROPY_BASE_KERNEL_H
+
+#include <linux/slab.h> /* needed for kzalloc */
+#include <linux/module.h> /* needed for random_get_entropy */
+#include <linux/fips.h> /* needed for fips_enabled */
+#include <linux/time.h> /* needed for __getnstimeofday */
+
+static inline void jent_get_nstime(__u64 *out)
+{
+	struct timespec ts;
+	__u64 tmp = 0;
+
+	tmp = random_get_entropy();
+
+	/* If random_get_entropy does not return a value (which is possible on,
+	 * for example, MIPS), invoke __getnstimeofday
+	 * hoping that there are timers we can work with.
+	 *
+	 * The list of available timers can be obtained from
+	 * /sys/devices/system/clocksource/clocksource0/available_clocksource
+	 * and are registered with clocksource_register()
+	 */
+	if((0 == tmp) &&
+#ifndef MODULE
+	   (0 == timekeeping_valid_for_hres()) && 
+#endif
+	   (0 == __getnstimeofday(&ts)))
+	{
+		tmp = ts.tv_sec;
+		tmp = tmp << 32;
+		tmp = tmp | ts.tv_nsec;
+	}
+
+	*out = tmp;
+}
+
+static inline void *jent_zalloc(size_t len)
+{
+	/* We consider kernel memory as secure -- if somebody breaks it,
+	 * the user has much more pressing problems than the state of our
+	 * RNG */
+#define CONFIG_CRYPTO_CPU_JITTERENTROPY_SECURE_MEMORY
+	return kzalloc(len, GFP_KERNEL);
+}
+static inline void jent_zfree(void *ptr, unsigned int len)
+{
+	kzfree(ptr);
+}
+
+static inline int jent_fips_enabled(void)
+{
+	return fips_enabled;
+}
+
+#endif /* _JITTERENTROPY_BASE_KERNEL_H */
+
diff --git a/drivers/char/jitterentropy-base.c b/drivers/char/jitterentropy-base.c
new file mode 100644
index 0000000..6cf6f59
--- /dev/null
+++ b/drivers/char/jitterentropy-base.c
@@ -0,0 +1,731 @@
+ï»¿/*
+ * Non-physical true random number generator based on timing jitter.
+ *
+ * Copyright Stephan Mueller <smueller@chronox.de>, 2014
+ *
+ * Design
+ * ======
+ *
+ * See documentation in doc/ folder.
+ *
+ * Interface
+ * =========
+ *
+ * See documentation in doc/ folder.
+ *
+ * License
+ * =======
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU General Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
+ * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+
+#include "jitterentropy.h"
+
+#ifndef CONFIG_CRYPTO_CPU_JITTERENTROPY_STAT
+ /* only check optimization in a compilation for real work */
+ #ifdef __OPTIMIZE__
+  #error "The CPU Jitter random number generator must not be compiled with optimizations. See documentation. Use the compiler switch -O0 for compiling jitterentropy-base.c."
+ #endif
+#endif
+
+/*
+ * Update of the loop count used for the next round of
+ * an entropy collection.
+ *
+ * Input:
+ * @ec entropy collector struct -- may be NULL
+ * @bits is the number of low bits of the timer to consider
+ * @min is the number of bits we shift the timer value to the right at
+ * 	the end to make sure we have a guaranteed minimum value
+ *
+ * Return:
+ * Newly calculated loop counter
+ */
+static __u64 jent_loop_shuffle(struct rand_data *ec,
+			       unsigned int bits, unsigned int min)
+{
+	__u64 time = 0;
+	__u64 shuffle = 0;
+	int i = 0;
+	unsigned int mask = (1<<bits) - 1;
+
+	jent_get_nstime(&time);
+	/* mix the current state of the random number into the shuffle
+	 * calculation to balance that shuffle a bit more */
+	if (ec)
+		time ^= ec->data;
+	/* we fold the time value as much as possible to ensure that as many
+	 * bits of the time stamp are included as possible */
+	for(i = 0; (DATA_SIZE_BITS / bits) > i; i++) {
+		shuffle ^= time & mask;
+		time = time >> bits;
+	}
+
+	/* We add a lower boundary value to ensure we have a minimum
+	 * RNG loop count. */
+	return (shuffle + (1<<min));
+}
+
+/***************************************************************************
+ * Noise sources
+ ***************************************************************************/
+
+/*
+ * CPU Jitter noise source -- this is the noise source based on the CPU
+ * 			      execution time jitter
+ *
+ * This function folds the time into TIME_ENTROPY_BITS bits by iterating
+ * through the DATA_SIZE_BITS bit time value as follows: assume our time value
+ * is 0xaaabbbcccddd, TIME_ENTROPY_BITS is 3
+ * 1st loop, 1st shift generates 0xddd000000000
+ * 1st loop, 2nd shift generates 0x000000000ddd
+ * 2nd loop, 1st shift generates 0xcccddd000000
+ * 2nd loop, 2nd shift generates 0x000000000ccc
+ * 3rd loop, 1st shift generates 0xbbbcccddd000
+ * 3rd loop, 2nd shift generates 0x000000000bbb
+ * 4th loop, 1st shift generates 0xaaabbbcccddd
+ * 4th loop, 2nd shift generates 0x000000000aaa
+ * Now, the values at the end of the 2nd shifts are XORed together.
+ * Note, the loop only performs (DATA_SIZE_BITS / TIME_SIZE) iterations. If the
+ * division is not complete, it takes the lower bound (e.g. 64 / 3 would result
+ * 21). Thus, the upmost bits that are less than TIME_SIZE in size (which are
+ * assumed to have no entropy to begin with) are discarded.
+ *
+ * The code is deliberately inefficient and shall stay that way. This function
+ * is the root cause why the code shall be compiled without optimization. This
+ * function not only acts as folding operation, but this function's execution
+ * is used to measure the CPU execution time jitter. Any change to the loop in
+ * this function implies that careful retesting must be done.
+ *
+ * Input:
+ * @ec entropy collector struct -- may be NULL
+ * @time time stamp to be folded
+ * @loop_cnt if a value not equal to 0 is set, use the given value as number of
+ *	     loops to perform the folding
+ *
+ * Output:
+ * @folded result of folding operation
+ *
+ * Return:
+ * Number of loops the folding operation is performed
+ */
+static __u64 jent_fold_time(struct rand_data *ec, __u64 time,
+			    __u64 *folded, __u64 loop_cnt)
+{
+	int i, j;
+	__u64 new = 0;
+#define MAX_FOLD_LOOP_BIT 4
+#define MIN_FOLD_LOOP_BIT 0
+	__u64 fold_loop_cnt =
+		jent_loop_shuffle(ec, MAX_FOLD_LOOP_BIT, MIN_FOLD_LOOP_BIT);
+
+	/* testing purposes -- allow test app to set the counter, not
+	 * needed during runtime */
+	if (loop_cnt)
+		fold_loop_cnt = loop_cnt;
+	for (j = 0; j < fold_loop_cnt; j++) {
+		new = 0;
+		for (i = 1; (DATA_SIZE_BITS / TIME_ENTROPY_BITS) >= i; i++) {
+			__u64 tmp = time <<
+				(DATA_SIZE_BITS - (TIME_ENTROPY_BITS * i));
+			tmp = tmp >> (DATA_SIZE_BITS - TIME_ENTROPY_BITS);
+			new ^= tmp;
+		}
+	}
+	*folded = new;
+	return fold_loop_cnt;
+}
+
+/* 
+ * Memory Access noise source -- this is a noise source based on variations in
+ * 				 memory access times
+ *
+ * This function performs memory accesses which will add to the timing
+ * variations due to an unknown amount of CPU wait states that need to be
+ * added when accessing memory. The memory size should be larger than the L1
+ * caches as outlined in the documentation and the associated testing.
+ *
+ * The L1 cache has a very high bandwidth, albeit its access rate is  usually
+ * slower than accessing CPU registers. Therefore, L1 accesses only add minimal
+ * variations as the CPU has hardly to wait. Starting with L2, significant
+ * variations are added because L2 typically does not belong to the CPU any more
+ * and therefore a wider range of CPU wait states is necessary for accesses.
+ * L3 and real memory accesses have even a wider range of wait states. However,
+ * to reliably access either L3 or memory, the ec->mem memory must be quite large
+ * which is usually not desirable.
+ *
+ * Input:
+ * @ec Reference to the entropy collector with the memory access data -- if
+ *     the reference to the memory block to be accessed is NULL, this noise
+ *     source is disabled
+ *
+ * Output:
+ * nothing -- the state of the memory access data in @ec is updated
+ *
+ * Return:
+ * Number of memory access operations
+ */
+static unsigned int jent_memaccess(struct rand_data *ec)
+{
+	unsigned char *tmpval = NULL;
+	unsigned int wrap = 0;
+	unsigned int i = 0;
+
+	if (NULL == ec || NULL == ec->mem)
+		return 0;
+	wrap = ec->memblocksize * ec->memblocks;
+	for (i = 0; i < ec->memaccessloops; i++) {
+		tmpval = ec->mem + ec->memlocation;
+		/* memory access: just add 1 to one byte,
+		 * wrap at 255 -- memory access implies read
+		 * from and write to memory location */
+		*tmpval = (*tmpval + 1) & 0xff;
+		/* Addition of memblocksize - 1 to pointer
+		 * with wrap around logic to ensure that every
+		 * memory location is hit evenly
+		 */
+		ec->memlocation = ec->memlocation + ec->memblocksize - 1;
+		ec->memlocation = ec->memlocation % wrap;
+	}
+	return i;
+}
+
+/***************************************************************************
+ * Start of entropy processing logic
+ ***************************************************************************/
+
+/*
+ * This is the heart of the entropy generation: calculate time deltas and
+ * use the CPU jitter in the time deltas. The jitter is folded into one
+ * bit. You can call this function the "random bit generator" as it
+ * produces one random bit per invocation.
+ *
+ * WARNING: ensure that ->prev_time is primed before using the output
+ * 	    of this function! This can be done by calling this function
+ * 	    and not using its result.
+ *
+ * Input:
+ * @entropy_collector Reference to entropy collector
+ *
+ * Return:
+ * One random bit
+ *
+ */
+static __u64 jent_measure_jitter(struct rand_data *entropy_collector)
+{
+	__u64 time = 0;
+	__u64 delta = 0;
+	__u64 data = 0;
+
+	/* Invoke one noise source before time measurement to add variations */
+	jent_memaccess(entropy_collector);
+
+	/* Get time stamp and calculate time delta to previous invocation 
+	 * to measure the timing variations with the previous invocation */
+	jent_get_nstime(&time);
+	delta = time - entropy_collector->prev_time;
+	entropy_collector->prev_time = time;
+
+	/* Now call the next noise sources which also folds the data */
+	jent_fold_time(entropy_collector, delta, &data, 0);
+
+	return data;
+}
+
+/*
+ * Von Neuman unbias as explained in RFC 4086 section 4.2. As shown in the
+ * documentation of that RNG, the bits from jent_measure_jitter are considered
+ * independent which implies that the Von Neuman unbias operation is applicable.
+ * A proof of the Von-Neumann unbias operation to remove skews is given in the
+ * document "A proposal for: Functionality classes for random number
+ * generators", version 2.0 by Werner Schindler, section 5.4.1.
+ *
+ * Input:
+ * @entropy_collector Reference to entropy collector
+ *
+ * Return:
+ * One random bit
+ */
+static __u64 jent_unbiased_bit(struct rand_data *entropy_collector)
+{
+	if (1 == entropy_collector->disable_unbias)
+		return (jent_measure_jitter(entropy_collector));
+	do {
+		__u64 a = jent_measure_jitter(entropy_collector);
+		__u64 b = jent_measure_jitter(entropy_collector);
+		if (a == b)
+			continue;
+		if (1 == a)
+			return 1;
+		else
+			return 0;
+	} while (1);
+}
+
+/*
+ * Shuffle the pool a bit by mixing some value with a bijective function (XOR)
+ * into the pool.
+ *
+ * The function generates a mixer value that depends on the bits set and the
+ * location of the set bits in the random number generated by the entropy
+ * source. Therefore, based on the generated random number, this mixer value
+ * can have 2**64 different values. That mixer value is initialized with the
+ * first two SHA-1 constants. After obtaining the mixer value, it is XORed into
+ * the random number.
+ *
+ * The mixer value is not assumed to contain any entropy. But due to the XOR
+ * operation, it can also not destroy any entropy present in the entropy pool.
+ *
+ * Input:
+ * @entropy_collector Reference to entropy collector
+ *
+ * Output:
+ * nothing
+ */
+static void jent_stir_pool(struct rand_data *entropy_collector)
+{
+	/* to shut up GCC on 32 bit, we have to initialize the 64 variable
+	 * with two 32 bit variables */
+	union c {
+		__u64 u64;
+		__u32 u32[2];
+	};
+	/* This constant is derived from the first two 32 bit initialization
+	 * vectors of SHA-1 as defined in FIPS 180-4 section 5.3.1 */
+	union c constant;
+	/* The start value of the mixer variable is derived from the third
+	 * and fourth 32 bit initialization vector of SHA-1 as defined in
+	 * FIPS 180-4 section 5.3.1 */
+	union c mixer;
+	int i = 0;
+
+	/* Store the SHA-1 constants in reverse order to make up the 64 bit
+	 * value -- this applies to a little endian system, on a big endian
+	 * system, it reverses as expected. But this really does not matter
+	 * as we do not rely on the specific numbers. We just pick the SHA-1
+	 * constants as they have a good mix of bit set and unset. */
+	constant.u32[1] = 0x67452301;
+	constant.u32[0] = 0xefcdab89;
+	mixer.u32[1] = 0x98badcfe;
+	mixer.u32[0] = 0x10325476;
+
+	for (i = 0; i < DATA_SIZE_BITS; i++) {
+		/* get the i-th bit of the input random number and only XOR
+		 * the constant into the mixer value when that bit is set */
+		if ((entropy_collector->data >> i) & 0x0000000000000001)
+			mixer.u64 ^= constant.u64;
+		mixer.u64 = rol64(mixer.u64, 1);
+	}
+	entropy_collector->data ^= mixer.u64;
+}
+
+/*
+ * Generator of one 64 bit random number
+ * Function fills rand_data->data
+ *
+ * Input:
+ * @entropy_collector Reference to entropy collector
+ *
+ * Return:
+ * Number of loops the entropy collection is performed.
+ */
+static void jent_gen_entropy(struct rand_data *entropy_collector)
+{
+	unsigned int k;
+
+	/* number of loops for the entropy collection depends on the size of
+	 * the random number and the size of the folded value. We want to
+	 * ensure that we pass over each bit of the random value once with the
+	 * folded value.  E.g. if we have a random value of 64 bits and 2 bits
+	 * of folded size, we need 32 entropy collection loops. If the random
+	 * value size is not divisible by the folded value size, we have as
+	 * many loops to cover each random number value bit at least once. E.g.
+	 * 64 bits random value size and the folded value is 3 bits, we need 22
+	 * loops to cover the 64 bits at least once. */
+	/* We multiply the loop value with ->osr to obtain the oversampling
+	 * rate requested by the caller */
+	for (k = 0;
+	     k < ((((DATA_SIZE_BITS - 1) / TIME_ENTROPY_BITS) + 1) *
+		  entropy_collector->osr);
+	     k++) {
+		__u64 data = 0;
+		__u64 prev_data = entropy_collector->data;
+		/* priming of the ->prev_time value in first loop iteration */
+		if (!k)
+			jent_measure_jitter(entropy_collector);
+
+		data = jent_unbiased_bit(entropy_collector);
+		entropy_collector->data ^= data;
+		entropy_collector->data = rol64(entropy_collector->data,
+						TIME_ENTROPY_BITS);
+
+		/* statistics testing only */
+		jent_bit_count(entropy_collector, prev_data);
+	}
+	if (entropy_collector->stir)
+		jent_stir_pool(entropy_collector);
+}
+
+/* the continuous test required by FIPS 140-2 -- the function automatically
+ * primes the test if needed.
+ *
+ * Return:
+ * 0 if FIPS test passed
+ * < 0 if FIPS test failed
+ */
+static int jent_fips_test(struct rand_data *entropy_collector)
+{
+	if (!jent_fips_enabled())
+		return 0;
+
+	/* shall we somehow allow the caller to reset that? Probably
+	 * not, because the caller can de-allocate the entropy collector
+	 * instance and set up a new one. */
+	if (entropy_collector->fips_fail)
+		return -1;
+
+	/* prime the FIPS test */
+	if (!entropy_collector->old_data) {
+		entropy_collector->old_data = entropy_collector->data;
+		jent_gen_entropy(entropy_collector);
+	}
+
+	if (entropy_collector->data == entropy_collector->old_data) {
+		entropy_collector->fips_fail = 1;
+		return -1;
+	}
+	entropy_collector->old_data = entropy_collector->data;
+
+	return 0;
+}
+
+/*
+ * Entry function: Obtain entropy for the caller.
+ *
+ * This function invokes the entropy gathering logic as often to generate
+ * as many bytes as requested by the caller. The entropy gathering logic
+ * creates 64 bit per invocation.
+ *
+ * This function truncates the last 64 bit entropy value output to the exact
+ * size specified by the caller.
+ *
+ * @data: pointer to buffer for storing random data -- buffer must already
+ *        exist
+ * @len: size of the buffer, specifying also the requested number of random
+ *       in bytes
+ *
+ * return: number of bytes returned when request is fulfilled or an error
+ *
+ * The following error codes can occur:
+ * 	-1	FIPS 140-2 continuous self test failed
+ * 	-2	entropy_collector is NULL
+ */
+int jent_read_entropy(struct rand_data *entropy_collector,
+		      char *data, size_t len)
+{
+	char *p = data;
+	int ret = 0;
+	size_t orig_len = len;
+
+	if (NULL == entropy_collector)
+		return -2;
+
+	while (0 < len) {
+		size_t tocopy;
+		jent_gen_entropy(entropy_collector);
+		ret = jent_fips_test(entropy_collector);
+		if (0 > ret)
+			return ret;
+
+		if ((DATA_SIZE_BITS / 8) < len)
+			tocopy = (DATA_SIZE_BITS / 8);
+		else
+			tocopy = len;
+		memcpy(p, &entropy_collector->data, tocopy);
+
+		len -= tocopy;
+		p += tocopy;
+	}
+
+	/* To be on the safe side, we generate one more round of entropy
+	 * which we do not give out to the caller. That round shall ensure
+	 * that in case the calling application crashes, memory dumps, pages
+	 * out, or due to the CPU Jitter RNG lingering in memory for long
+	 * time without being moved and an attacker cracks the application,
+	 * all he reads in the entropy pool is a value that is NEVER EVER
+	 * being used for anything. Thus, he does NOT see the previous value
+	 * that was returned to the caller for cryptographic purposes.
+	 */
+	/* If we use secured memory, do not use that precaution as the secure
+	 * memory protects the entropy pool. Moreover, note that using this
+	 * call reduces the speed of the RNG by up to half */
+#ifndef CONFIG_CRYPTO_CPU_JITTERENTROPY_SECURE_MEMORY
+	jent_gen_entropy(entropy_collector);
+#endif
+	return orig_len;
+}
+#if defined(__KERNEL__) && !defined(MODULE)
+EXPORT_SYMBOL(jent_read_entropy);
+#endif
+
+/***************************************************************************
+ * Initialization logic
+ ***************************************************************************/
+
+struct rand_data *jent_entropy_collector_alloc(unsigned int osr,
+					       unsigned int flags)
+{
+	struct rand_data *entropy_collector;
+
+	entropy_collector = jent_zalloc(sizeof(struct rand_data));
+	if (NULL == entropy_collector)
+		return NULL;
+
+	if (!(flags & JENT_DISABLE_MEMORY_ACCESS)) {
+		/* Allocate memory for adding variations based on memory
+		 * access
+		 */
+		entropy_collector->mem = 
+			(unsigned char *)jent_zalloc(JENT_MEMORY_SIZE);
+		if (NULL == entropy_collector->mem) {
+			jent_zfree(entropy_collector, sizeof(struct rand_data));
+			return NULL;
+		}
+		entropy_collector->memblocksize = JENT_MEMORY_BLOCKSIZE;
+		entropy_collector->memblocks = JENT_MEMORY_BLOCKS;
+		entropy_collector->memaccessloops = JENT_MEMORY_ACCESSLOOPS;
+	}
+
+	/* verify and set the oversampling rate */
+	if (0 == osr)
+		osr = 1; /* minimum sampling rate is 1 */
+	entropy_collector->osr = osr;
+
+	entropy_collector->stir = 1;
+	if (flags & JENT_DISABLE_STIR)
+		entropy_collector->stir = 0;
+	if (flags & JENT_DISABLE_UNBIAS)
+		entropy_collector->disable_unbias = 1;
+
+	/* fill the data pad with non-zero values */
+	jent_gen_entropy(entropy_collector);
+
+	/* initialize the FIPS 140-2 continuous test if needed */
+	jent_fips_test(entropy_collector);
+
+	return entropy_collector;
+}
+#if defined(__KERNEL__) && !defined(MODULE)
+EXPORT_SYMBOL(jent_entropy_collector_alloc);
+#endif
+
+void jent_entropy_collector_free(struct rand_data *entropy_collector)
+{
+	if (NULL != entropy_collector->mem)
+		jent_zfree(entropy_collector->mem, JENT_MEMORY_SIZE);
+	entropy_collector->mem = NULL;
+	if (NULL != entropy_collector)
+		jent_zfree(entropy_collector, sizeof(struct rand_data));
+	entropy_collector = NULL;
+}
+#if defined(__KERNEL__) && !defined(MODULE)
+EXPORT_SYMBOL(jent_entropy_collector_free);
+#endif
+
+int jent_entropy_init(void)
+{
+	int i;
+	__u64 delta_sum = 0;
+	__u64 old_delta = 0;
+	int time_backwards = 0;
+	int count_var = 0;
+	int count_mod = 0;
+
+	/* We could perform statistical tests here, but the problem is
+	 * that we only have a few loop counts to do testing. These
+	 * loop counts may show some slight skew and we produce
+	 * false positives.
+	 *
+	 * Moreover, only old systems show potentially problematic
+	 * jitter entropy that could potentially be caught here. But
+	 * the RNG is intended for hardware that is available or widely
+	 * used, but not old systems that are long out of favor. Thus,
+	 * no statistical tests.
+	 */
+
+	/* We could add a check for system capabilities such as clock_getres or
+	 * check for CONFIG_X86_TSC, but it does not make much sense as the
+	 * following sanity checks verify that we have a high-resolution
+	 * timer. */
+	/* TESTLOOPCOUNT needs some loops to identify edge systems. 100 is
+	 * definitely too little. */
+#define TESTLOOPCOUNT 300
+#define CLEARCACHE 100
+	for (i = 0; (TESTLOOPCOUNT + CLEARCACHE) > i; i++) {
+		__u64 time = 0;
+		__u64 time2 = 0;
+		__u64 folded = 0;
+		__u64 delta = 0;
+
+		jent_get_nstime(&time);
+		jent_fold_time(NULL, time, &folded, 1<<MIN_FOLD_LOOP_BIT);
+		jent_get_nstime(&time2);
+
+		/* test whether timer works */
+		if (!time || !time2)
+			return ENOTIME;
+		delta = time2 - time;
+		/* test whether timer is fine grained enough to provide
+		 * delta even when called shortly after each other -- this
+		 * implies that we also have a high resolution timer */
+		if (!delta)
+			return ECOARSETIME;
+		/* TIME_ENTROPY_BITS states the absolute minimum entropy we
+		 * assume the time variances have. As we also check for
+		 * delta of deltas, we ensure that there is a varying delta
+		 * value, preventing identical time spans */
+		if (TIME_ENTROPY_BITS > delta)
+			return EMINVARIATION;
+
+		/* up to here we did not modify any variable that will be
+		 * evaluated later, but we already performed some work. Thus we
+		 * already have had an impact on the caches, branch prediction,
+		 * etc. with the goal to clear it to get the worst case
+		 * measurements. */
+		if (CLEARCACHE > i)
+			continue;
+
+		/* test whether we have an increasing timer */
+		if (!(time2 > time))
+			time_backwards++;
+
+		if (!(delta % 100))
+			count_mod++;
+
+		/* ensure that we have a varying delta timer which is necessary
+		 * for the calculation of entropy -- perform this check
+		 * only after the first loop is executed as we need to prime
+		 * the old_data value */
+		if (i) {
+			if (delta != old_delta)
+				count_var++;
+			if (delta > old_delta)
+				delta_sum += (delta - old_delta);
+			else
+				delta_sum += (old_delta - delta);
+		}
+		old_delta = delta;
+	}
+
+	/* we allow up to three times the time running backwards.
+	 * CLOCK_REALTIME is affected by adjtime and NTP operations. Thus,
+	 * if such an operation just happens to interfere with our test, it
+	 * should not fail. The value of 3 should cover the NTP case being
+	 * performed during our test run. */
+	if (3 < time_backwards)
+		return ENOMONOTONIC;
+	/* Error if the time variances are always identical */
+	if (!delta_sum)
+		return EVARVAR;
+
+	/* Variations of deltas of time must on average be larger
+	 * than TIME_ENTROPY_BITS to ensure the entropy estimation
+	 * implied with TIME_ENTROPY_BITS is preserved */
+	if (!(delta_sum / TESTLOOPCOUNT) > TIME_ENTROPY_BITS)
+		return EMINVARVAR;
+
+	/* Ensure that we have variations in the time stamp below 10 for at least
+	 * 10% of all checks -- on some platforms, the counter increments in
+	 * multiples of 100, but not always */
+	if ((TESTLOOPCOUNT/10 * 9) < count_mod)
+		return ECOARSETIME;
+
+	return 0;
+}
+#if defined(__KERNEL__) && !defined(MODULE)
+EXPORT_SYMBOL(jent_entropy_init);
+#endif
+
+/***************************************************************************
+ * Statistical test logic not compiled for regular operation
+ ***************************************************************************/
+
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_STAT
+/* Statistical tests: invoke the entropy collector and sample time results
+ * for it, the random data is never returned - every call to this function
+ * generates one random number.
+ * This function is only meant for statistical analysis purposes and not
+ * for general use
+ */
+void jent_gen_entropy_stat(struct rand_data *entropy_collector,
+	       		   struct entropy_stat *stat)
+{
+	/* caller is allowed to set the entropy collection loop to a fixed
+	 * value -- we still call shuffle for the time measurements */
+	jent_init_statistic(entropy_collector);
+	jent_gen_entropy(entropy_collector);
+	jent_calc_statistic(entropy_collector, stat, DATA_SIZE_BITS);
+}
+
+/* Statistical test: obtain the distribution of the folded time value from
+ * jent_fold_time */
+void jent_fold_time_stat(struct rand_data *ec, __u64 *fold, __u64 *loop_cnt)
+{
+	__u64 time = 0;
+	__u64 time2 = 0;
+	__u64 folded = 0;
+	jent_get_nstime(&time);
+	jent_memaccess(ec);
+	/* implement the priming logic */
+	jent_fold_time(ec, time, &folded, 0);
+	jent_get_nstime(&time2);
+	time2 = time2 - time;
+	*loop_cnt = jent_fold_time(ec, time2, &folded, 0);
+	*fold = folded;
+}
+
+/* Statistical test: return the time duration for the folding operation. If min
+ * is set, perform the given number of foldings. Otherwise, allow the
+ * loop count shuffling to define the number of foldings. */
+__u64 jent_fold_var_stat(struct rand_data *ec, unsigned int min)
+{
+	__u64 time = 0;
+	__u64 time2 = 0;
+	__u64 folded = 0;
+	jent_get_nstime(&time);
+	jent_memaccess(ec);
+	jent_fold_time(NULL, time, &folded, min);
+	jent_get_nstime(&time2);
+	return ((time2 - time));
+}
+#endif /* CONFIG_CRYPTO_CPU_JITTERENTROPY_STAT */
diff --git a/drivers/char/jitterentropy-dbg.c b/drivers/char/jitterentropy-dbg.c
new file mode 100644
index 0000000..af78f07
--- /dev/null
+++ b/drivers/char/jitterentropy-dbg.c
@@ -0,0 +1,662 @@
+/*
+ * Non-physical true random number generator based on timing jitter - DebugFS
+ *
+ * Copyright Stephan Mueller <smueller@chronox.de>, 2013
+ *
+ * License
+ * =======
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU General Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
+ * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+#include <linux/string.h>
+
+#include <linux/debugfs.h>
+
+/* connection to entropy collector */
+#include "jitterentropy.h"
+/* connection to DRNG manager */
+#include "jitterentropy-drng.h"
+#include "jitterentropy-dbg.h"
+
+/************************************************
+ * Definition of the DRNG
+ ************************************************/
+
+/* Raw entropy interface */
+static struct jent_raw raw_entropy;
+
+static inline int jent_dbg_raw_bytes(char *data, size_t len)
+{
+        return jent_drng_get_bytes_raw(&raw_entropy, data, len);
+}
+
+/* Handle for the regular DRNG which is reseeded once in a while */
+static struct jent_drng jent_reg_drng;
+/* Handle for strong DRNG which is constantly reseeded */
+static struct jent_drng jent_strong_drng;
+
+static inline void jent_dbg_get_stat(struct jent_stat *src,
+				     struct jent_stat *stat)
+{
+	stat->read_data = src->read_data;
+	stat->num_reseed = src->num_reseed;
+	stat->num_rekey = src->num_rekey;
+}
+
+static inline void jent_dbg_raw_get_stat(struct jent_stat *stat)
+{
+	jent_dbg_get_stat(&raw_entropy.jent_stat, stat);
+}
+
+static inline void jent_dbg_reg_get_stat(struct jent_stat *stat)
+{
+	jent_dbg_get_stat(&jent_reg_drng.jent_stat, stat);
+}
+
+static inline void jent_dbg_strong_get_stat(struct jent_stat *stat)
+{
+	jent_dbg_get_stat(&jent_strong_drng.jent_stat, stat);
+}
+
+/*
+ * Entry function: Obtain random numbers out of DRNG.
+ *
+ * This function invokes the DRNG as often to generate as many bytes as
+ * requested by the caller. This function also ensures that the DRNG is always
+ * properly seeded.
+ *
+ * This function truncates the output to the exact size specified by the caller.
+ *
+ * @data: pointer to buffer for storing random data -- buffer must already
+ *        exist
+ * @len: size of the buffer, specifying also the requested number of random
+ *       in bytes
+ *
+ * return: 0 when request is fulfilled or an error
+ *
+ * The following error codes can occur:
+ *      EAGAIN  Initialization, seeding, reseeding of DRNG failed
+ *      EFAULT  Generation of random numbers out of DRNG failed
+ */
+static inline int jent_dbg_random_bytes(char *data, size_t len)
+{
+        return jent_drng_get_bytes(&jent_reg_drng,
+				   MAX_BYTES_RESEED, MAX_BYTES_REKEY,
+				   data, len);
+}
+
+/*
+ * Entry function: Obtain random numbers out of constantly seeded DRNG.
+ *                 It follows the same logic as jent_dbg_random_bytes
+ *                 with the exception that the DRNG is constantly seeded.
+ */
+static inline int jent_dbg_strong_random_bytes(char *data, size_t len)
+{
+        return jent_drng_get_bytes(&jent_strong_drng,
+				   MAX_BYTES_STRONG_RESEED,
+				   MAX_BYTES_STRONG_REKEY,
+				   data, len);
+}
+
+/***********************************************
+ * The interface
+ ***********************************************/
+
+/* debugfs interface */
+struct jent_debugfs {
+	struct dentry *jent_debugfs_root; /* /sys/kernel/debug/jent */
+	struct dentry *jent_debugfs_stat; /* /sys/kernel/debug/jent/stat */
+	struct dentry *jent_debugfs_stattimer; /* /sys/kernel/debug/jent/stat-timer */
+	struct dentry *jent_debugfs_statfold; /* /sys/kernel/debug/jent/stat-fold */
+	struct dentry *jent_debugfs_statbits; /* /sys/kernel/debug/jent/stat-bits */
+	struct dentry *jent_debugfs_seed; /* /sys/kernel/debug/jent/seed */
+	struct dentry *jent_debugfs_drng; /* /sys/kernel/debug/jent/drng */
+	struct dentry *jent_debugfs_strong; /* /sys/kernel/debug/jent/strong */
+	struct dentry *jent_debugfs_timer; /* /sys/kernel/debug/jent/timer */
+	struct dentry *jent_debugfs_clc; /* /sys/kernel/debug/jent/collection_loop_count */
+};
+static struct jent_debugfs jent_debugfs;
+
+static ssize_t jent_debugfs_stat_read(struct file *file, char __user *buf,
+			      size_t nbytes, loff_t *ppos)
+{
+	char *out;
+	struct jent_stat raw_stat;
+	struct jent_stat reg_stat;
+	struct jent_stat strong_stat;
+	int ret = 0;
+
+	jent_dbg_raw_get_stat(&raw_stat);
+	jent_dbg_reg_get_stat(&reg_stat);
+	jent_dbg_strong_get_stat(&strong_stat);
+
+	out = kasprintf(GFP_KERNEL,
+		 "Raw:     read %zu\n"
+		 "Regular: read %zu - reseed %zu - rekey: %zu\n"
+		 "Strong:  read %zu - reseed %zu - rekey: %zu\n",
+		 raw_stat.read_data,
+		 reg_stat.read_data, reg_stat.num_reseed, reg_stat.num_rekey,
+		 strong_stat.read_data, strong_stat.num_reseed, strong_stat.num_rekey
+		 );
+	if (!out)
+		return -ENOMEM;
+	ret = simple_read_from_buffer(buf, nbytes, ppos, out, strlen(out));
+	kfree(out);
+	return ret;
+}
+
+static struct file_operations jent_stat_fops = {
+	.owner = THIS_MODULE,
+	.read = jent_debugfs_stat_read,
+};
+
+static ssize_t jent_debugfs_stattimer_read(struct file *file, char __user *buf,
+					   size_t nbytes, loff_t *ppos)
+{
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_STAT
+	char *out;
+	ssize_t total = 0;
+	loff_t pos = *ppos;
+	struct entropy_stat stat;
+	ssize_t len = 0;
+	struct rand_data *ec = jent_entropy_collector_alloc(1, 0);
+	if (!ec)
+		return -ENOMEM;
+	ec->entropy_stat.enable_bit_test = 0;
+
+	while (0 < nbytes) {
+		__u64 delta = -1;
+		__u64 deltadelta = -1;
+
+		/* get data */
+		jent_gen_entropy_stat(ec, &stat);
+		delta = stat.collection_end - stat.collection_begin;
+		if (stat.old_delta > delta)
+			deltadelta = stat.old_delta - delta;
+		else
+			deltadelta = delta - stat.old_delta;
+
+		/* feed it to user space */
+		out = kasprintf(GFP_KERNEL, "%llu %llu %u\n", delta, deltadelta,
+				stat.collection_loop_cnt);
+		if (!out) {
+			len = -ENOMEM;
+			break;
+		}
+		len = strlen(out);
+		/* here we potentially discard the information from one
+		 * generated round -- dd will cry, but we do not care */
+		if (nbytes < len)
+			break;
+		if (copy_to_user(buf+pos+total, out, len)) {
+			len = -EFAULT;
+			break;
+		}
+		nbytes -= len;
+		total += len;
+		kfree(out);
+	}
+	jent_entropy_collector_free(ec);
+
+	return ((0 > len) ? len : total);
+#else
+	return -ENXIO;
+#endif
+}
+
+static struct file_operations jent_stattimer_fops = {
+	.owner = THIS_MODULE,
+	.read = jent_debugfs_stattimer_read,
+};
+
+static ssize_t jent_debugfs_statfold_read(struct file *file, char __user *buf,
+					  size_t nbytes, loff_t *ppos)
+{
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_STAT
+	char *out;
+	ssize_t total = 0;
+	loff_t pos = *ppos;
+	ssize_t len = 0;
+	struct rand_data *ec = NULL;
+
+	ec = jent_entropy_collector_alloc(1, 0);
+	if (NULL == ec)
+		return -ENOMEM;
+
+	while (0 < nbytes) {
+		__u64 duration = 0;
+		__u64 duration_min = 0;
+
+		/* get data */
+		duration = jent_fold_var_stat(ec, 0);
+		duration_min = jent_fold_var_stat(ec, 1);
+
+		/* feed it to user space */
+		out = kasprintf(GFP_KERNEL, "%llu %llu\n", duration, duration_min);
+		if (!out) {
+			len = -ENOMEM;
+			break;
+		}
+		len = strlen(out);
+		/* here we potentially discard the information from one
+		 * generated round -- dd will cry, but we do not care */
+		if (nbytes < len)
+			break;
+		if (copy_to_user(buf+pos+total, out, len)) {
+			len = -EFAULT;
+			break;
+		}
+		nbytes -= len;
+		total += len;
+		kfree(out);
+	}
+	jent_entropy_collector_free(ec);
+	return ((0 > len) ? len : total);
+#else
+	return -ENXIO;
+#endif
+}
+
+static struct file_operations jent_statfold_fops = {
+	.owner = THIS_MODULE,
+	.read = jent_debugfs_statfold_read,
+};
+
+static ssize_t jent_debugfs_statbits_read(struct file *file, char __user *buf,
+					  size_t nbytes, loff_t *ppos)
+{
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_STAT
+	char *out;
+	ssize_t total = 0;
+	loff_t pos = *ppos;
+	struct entropy_stat stat;
+	ssize_t len = 0;
+	struct rand_data *ec = jent_entropy_collector_alloc(1, 0);
+	if (!ec)
+		return -ENOMEM;
+	ec->entropy_stat.enable_bit_test = 1;
+
+	while (0 < nbytes) {
+		/* get data */
+		jent_gen_entropy_stat(ec, &stat);
+
+		/* feed it to user space */
+		out = kasprintf(GFP_KERNEL, "%u %u %u\n", stat.obsbits,
+				stat.setbits, stat.varbits);
+		if (!out) {
+			len = -ENOMEM;
+			break;
+		}
+		len = strlen(out);
+		/* here we potentially discard the information from one
+		 * generated round -- dd will cry, but we do not care */
+		if (nbytes < len)
+			break;
+		if (copy_to_user(buf+pos+total, out, len)) {
+			len = -EFAULT;
+			break;
+		}
+		nbytes -= len;
+		total += len;
+		kfree(out);
+	}
+	jent_entropy_collector_free(ec);
+
+	return ((0 > len) ? len : total);
+#else
+	return -ENXIO;
+#endif
+}
+
+static struct file_operations jent_statbits_fops = {
+	.owner = THIS_MODULE,
+	.read = jent_debugfs_statbits_read,
+};
+
+static ssize_t jent_debugfs_read_func(struct file *file,
+				      char __user *buf, size_t nbytes,
+				      loff_t *ppos, size_t chunk,
+				      int (*source)(char *out, size_t len))
+{
+	ssize_t total = 0;
+	int ret = 0;
+	loff_t pos = *ppos;
+	char *out;
+
+	if (!nbytes)
+		return -EINVAL;
+
+	/* chunk size shall be the block size in bytes of the RNG called with
+	 * *source
+	 * jent_read_entropy: 8
+	 * jent_dbg_random_bytes: 16
+	 * jent_dbg_strong_random_bytes: 16
+	 */
+	out = kzalloc(chunk, GFP_KERNEL);
+	if (!out)
+		return -ENOMEM;
+
+	while (nbytes > 0) {
+		int copy = min_t(int, chunk, nbytes);
+		ret = source(out, copy);
+		if (0 > ret) {
+			printk(DRIVER_NAME": could not obtain random data: %d\n", ret);
+			ret = -EAGAIN;
+			break;
+		}
+		if (copy_to_user(buf+pos+total, out, ret)) {
+			ret = -EFAULT;
+			break;
+		}
+		nbytes -= ret;
+		total += ret;
+	}
+
+	kzfree(out);
+
+	return ((0 > ret) ? ret : total);
+}
+
+static ssize_t jent_debugfs_seed_read(struct file *file, char __user *buf,
+			      size_t nbytes, loff_t *ppos)
+{
+	return jent_debugfs_read_func(file, buf, nbytes, ppos, 8,
+				      jent_dbg_raw_bytes);
+}
+
+static struct file_operations jent_seed_fops = {
+	.owner = THIS_MODULE,
+	.read = jent_debugfs_seed_read,
+};
+
+static ssize_t jent_debugfs_drng_read(struct file *file,
+				      char __user *buf, size_t nbytes,
+				      loff_t *ppos)
+{
+	return jent_debugfs_read_func(file, buf, nbytes, ppos, 16,
+				      jent_dbg_random_bytes);
+}
+
+static struct file_operations jent_drng_fops = {
+	.owner = THIS_MODULE,
+	.read = jent_debugfs_drng_read,
+};
+
+static ssize_t jent_debugfs_strong_read(struct file *file,
+					char __user *buf,
+					size_t nbytes, loff_t *ppos)
+{
+	return jent_debugfs_read_func(file, buf, nbytes, ppos, 16,
+				      jent_dbg_strong_random_bytes);
+}
+
+static struct file_operations jent_strong_fops = {
+	.owner = THIS_MODULE,
+	.read = jent_debugfs_strong_read,
+};
+
+static ssize_t jent_debugfs_timer_read(struct file *file,
+				       char __user *buf,
+				       size_t nbytes, loff_t *ppos)
+{
+	char *out;
+	ssize_t total = 0;
+	loff_t pos = *ppos;
+	size_t len = 0;
+
+	while (0 < nbytes) {
+		__u64 time, time2;
+		/* get data */
+		time = time2 = 0;
+		time = random_get_entropy();
+		time2 = random_get_entropy();
+
+		/* feed it to user space */
+		out = kasprintf(GFP_KERNEL, "%lld\n", (time2 - time));
+		if (!out) {
+			len = -ENOMEM;
+			break;
+		}
+		len = strlen(out);
+		/* here we potentially discard the information from one
+		 * generated round -- dd will cry, but we do not care */
+		if (nbytes < len)
+			break;
+		if (copy_to_user(buf+pos+total, out, len)) {
+			len = -EFAULT;
+			break;
+		}
+		nbytes -= len;
+		total += len;
+		kfree(out);
+	}
+
+	return ((0 > len) ? len : total);
+}
+
+static struct file_operations jent_timer_fops = {
+	.owner = THIS_MODULE,
+	.read = jent_debugfs_timer_read,
+};
+
+static ssize_t jent_debugfs_clc_read(struct file *file, char __user *buf,
+				     size_t nbytes, loff_t *ppos)
+{
+	char out[12];
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_STAT
+	/* no lock needed -- statistic analyses should be single threaded;
+	 * if not, it is the caller's fault if the value is not correct :-) */
+	unsigned int collection_loop_cnt =
+	       raw_entropy.entropy_collector->entropy_stat.collection_loop_cnt;
+#else
+	unsigned int collection_loop_cnt = -1;
+#endif /* CONFIG_CRYPTO_CPU_JITTERENTROPY_STAT */
+
+	memset(out, 0, sizeof(out));
+	snprintf(out, sizeof(out), "%u\n", collection_loop_cnt);
+	return simple_read_from_buffer(buf, nbytes, ppos, out, sizeof(out));
+}
+
+#if 0
+static ssize_t jent_debugfs_clc_write(struct file *file, const char __user *buf,
+				      size_t nbytes, loff_t *ppos)
+{
+	unsigned long collection_loop_cnt = 0;
+	char in[11];
+	int ret = 0;
+
+	ret = simple_write_to_buffer(in, nbytes, ppos, buf, sizeof(in));
+	if (0 >= ret)
+		return ret;
+	collection_loop_cnt = simple_strtoul(in, NULL, 10);
+	if (0 >= collection_loop_cnt || 1<<20 < collection_loop_cnt)
+		return -EINVAL;
+	else
+		jent_set_loop_cnt((unsigned int)collection_loop_cnt);
+	return ret;
+}
+#endif
+
+static struct file_operations jent_clc_fops = {
+	.owner = THIS_MODULE,
+	.read = jent_debugfs_clc_read,
+/*	.write = jent_debugfs_clc_write, */
+};
+
+/****************************************************************
+ * initialization of debugfs interfaces
+ ****************************************************************/
+
+int __init jent_dbg_init(void)
+{
+	int ret = -EINVAL;
+	jent_debugfs.jent_debugfs_stat = NULL;
+	jent_debugfs.jent_debugfs_stattimer = NULL;
+	jent_debugfs.jent_debugfs_statfold = NULL;
+	jent_debugfs.jent_debugfs_statbits = NULL;
+	jent_debugfs.jent_debugfs_seed = NULL;
+	jent_debugfs.jent_debugfs_drng = NULL;
+	jent_debugfs.jent_debugfs_strong = NULL;
+	jent_debugfs.jent_debugfs_timer = NULL;
+	jent_debugfs.jent_debugfs_clc = NULL;
+	jent_debugfs.jent_debugfs_root = NULL;
+
+	/* initialize the raw entropy **************/
+	ret = jent_drng_init_raw(&raw_entropy, JENT_DISABLE_STIR);
+	if (ret) {
+		printk(DRIVER_NAME": Raw entropy collector instantiation failed\n");
+		return ret;
+	}
+	printk(DRIVER_NAME": Raw entropy collector instantiated\n");
+
+	/* initialize the DRNGs **************/
+	ret = jent_drng_init_drng(&jent_reg_drng);
+	if (ret) {
+		printk(DRIVER_NAME": Regular DRNG instantiation failed\n");
+		goto cleanraw;
+	}
+	printk(DRIVER_NAME": Regular DRNG instantiated\n");
+	ret = jent_drng_init_drng(&jent_strong_drng);
+	if (ret) {
+		printk(DRIVER_NAME": Strong DRNG instantiation failed\n");
+		goto cleandrng;
+	}
+	printk(DRIVER_NAME": Strong DRNG instantiated\n");
+
+	/* instantiate the debugfs interfaces */
+	jent_debugfs.jent_debugfs_root =
+		debugfs_create_dir(DRIVER_NAME, NULL);
+	if (IS_ERR(jent_debugfs.jent_debugfs_root)) {
+		printk(DRIVER_NAME": initialization of debugfs directory failed\n");
+		goto cleanstrongdrng;
+	}
+	jent_debugfs.jent_debugfs_stat =
+		debugfs_create_file("stat", S_IRUGO,
+		jent_debugfs.jent_debugfs_root,
+		NULL, &jent_stat_fops);
+	if (IS_ERR(jent_debugfs.jent_debugfs_stat)) {
+		printk(DRIVER_NAME": initialization of stat file failed\n");
+		goto cleandir;
+	}
+	jent_debugfs.jent_debugfs_stattimer =
+		debugfs_create_file("stat-timer", S_IRUGO,
+		jent_debugfs.jent_debugfs_root,
+		NULL, &jent_stattimer_fops);
+	if (IS_ERR(jent_debugfs.jent_debugfs_stattimer)) {
+		printk(DRIVER_NAME": initialization of stat-timer file failed\n");
+		goto cleandir;
+	}
+	jent_debugfs.jent_debugfs_statfold =
+		debugfs_create_file("stat-fold", S_IRUGO,
+		jent_debugfs.jent_debugfs_root,
+		NULL, &jent_statfold_fops);
+	if (IS_ERR(jent_debugfs.jent_debugfs_statfold)) {
+		printk(DRIVER_NAME": initialization of stat-fold file failed\n");
+		goto cleandir;
+	}
+	jent_debugfs.jent_debugfs_statbits =
+		debugfs_create_file("stat-bits", S_IRUGO,
+		jent_debugfs.jent_debugfs_root,
+		NULL, &jent_statbits_fops);
+	if (IS_ERR(jent_debugfs.jent_debugfs_statbits)) {
+		printk(DRIVER_NAME": initialization of stat-bits file failed\n");
+		goto cleandir;
+	}
+	jent_debugfs.jent_debugfs_seed =
+		debugfs_create_file("seed", S_IRUGO,
+		jent_debugfs.jent_debugfs_root,
+		NULL, &jent_seed_fops);
+	if (IS_ERR(jent_debugfs.jent_debugfs_seed)) {
+		printk(DRIVER_NAME": initialization of seed file failed\n");
+		goto cleandir;
+	}
+	jent_debugfs.jent_debugfs_drng =
+		debugfs_create_file("drng", S_IRUGO,
+		jent_debugfs.jent_debugfs_root,
+		NULL, &jent_drng_fops);
+	if (IS_ERR(jent_debugfs.jent_debugfs_drng)) {
+		printk(DRIVER_NAME": initialization of drng file failed\n");
+		goto cleandir;
+	}
+	jent_debugfs.jent_debugfs_strong =
+		debugfs_create_file("strong-drng", S_IRUGO,
+		jent_debugfs.jent_debugfs_root,
+		NULL, &jent_strong_fops);
+	if (IS_ERR(jent_debugfs.jent_debugfs_strong)) {
+		printk(DRIVER_NAME": initialization of strong-drng file failed\n");
+		goto cleandir;
+	}
+	jent_debugfs.jent_debugfs_timer =
+		debugfs_create_file("timer", S_IRUGO,
+		jent_debugfs.jent_debugfs_root,
+		NULL, &jent_timer_fops);
+	if (IS_ERR(jent_debugfs.jent_debugfs_timer)) {
+		printk(DRIVER_NAME": initialization of timer file failed\n");
+		goto cleandir;
+	}
+	jent_debugfs.jent_debugfs_clc =
+		debugfs_create_file("collection_loop_count", S_IRUGO|S_IWUSR,
+		jent_debugfs.jent_debugfs_root,
+		NULL, &jent_clc_fops);
+	if (IS_ERR(jent_debugfs.jent_debugfs_clc)) {
+		printk(DRIVER_NAME": initialization of collection_loop_count file failed\n");
+		goto cleandir;
+	}
+	return 0;
+
+cleandir:
+	debugfs_remove_recursive(jent_debugfs.jent_debugfs_root);
+cleanstrongdrng:
+	jent_drng_cleanup_drng(&jent_strong_drng);
+cleandrng:
+	jent_drng_cleanup_drng(&jent_reg_drng);
+cleanraw:
+	jent_drng_cleanup_raw(&raw_entropy);
+
+	return ret;
+}
+
+/* we potentially call the exit function within an __init function */
+void /*__exit*/ jent_dbg_exit(void)
+{
+	debugfs_remove_recursive(jent_debugfs.jent_debugfs_root);
+	jent_drng_cleanup_drng(&jent_reg_drng);
+	jent_drng_cleanup_drng(&jent_strong_drng);
+	jent_drng_cleanup_raw(&raw_entropy);
+}
diff --git a/drivers/char/jitterentropy-dbg.h b/drivers/char/jitterentropy-dbg.h
new file mode 100644
index 0000000..5b412b6
--- /dev/null
+++ b/drivers/char/jitterentropy-dbg.h
@@ -0,0 +1,50 @@
+/*
+ * Non-physical true random number generator based on timing jitter.
+ *
+ * Copyright Stephan Mueller <smueller@chronox.de>, 2013
+ *
+ * License
+ * =======
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU General Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
+ * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+
+#ifndef _JITTERENTROPY_DBG_KERNEL_H
+#define _JITTERENTROPY_DBG_KERNEL_H
+
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_DBG
+int __init jent_dbg_init(void);
+void /*__exit*/ jent_dbg_exit(void);
+#endif
+
+#endif /* _JITTERENTROPY_DBG_KERNEL_H */
diff --git a/drivers/char/jitterentropy-drng.c b/drivers/char/jitterentropy-drng.c
new file mode 100644
index 0000000..6a111c3
--- /dev/null
+++ b/drivers/char/jitterentropy-drng.c
@@ -0,0 +1,372 @@
+/*
+ * Non-physical true random number generator based on timing jitter -- DRNG part
+ *
+ * Copyright Stephan Mueller <smueller@chronox.de>, 2013
+ *
+ * License
+ * =======
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU General Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
+ * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * Design
+ * ======
+ *
+ * See documentation in doc/ folder.
+ *
+ * Interface
+ * =========
+ *
+ * See documentation in doc/ folder.
+ *
+ * TODO: reseed and rekey are not (yet) implemented in the kernel crypto API.
+ *	 Therefore, this code always performs a DRNG reset when one of the
+ *	 limits are reached.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fips.h>
+
+#include <linux/crypto.h>
+#include <crypto/rng.h>
+#include <crypto/hash.h>
+
+#include "jitterentropy.h"
+#include "jitterentropy-drng.h"
+#include "jitterentropy-dbg.h"
+#include "jitterentropy-kcapi.h"
+
+/*************************************************************************
+ * DRNG instance seeded, reseeded and re-keyed by the jitter entropy
+ *
+ * This DRNG is intended to provide good random numbers out of a
+ * DRNG implemented in the kernel crypto API
+ *************************************************************************/
+
+/* clean up what jent_drng_init_drng allocated */
+void jent_drng_cleanup_drng(struct jent_drng *drng)
+{
+	spin_lock_bh(&drng->drng_lock);
+	if (NULL != drng->drng)
+		crypto_free_rng(drng->drng);
+	drng->drng = NULL;
+	if (NULL != drng->entropy_collector)
+		jent_entropy_collector_free(drng->entropy_collector);
+	drng->entropy_collector = NULL;
+	spin_unlock_bh(&drng->drng_lock);
+}
+
+void jent_drng_cleanup_raw(struct jent_raw *raw)
+{
+	spin_lock_bh(&raw->raw_lock);
+	if (NULL != raw->entropy_collector)
+		jent_entropy_collector_free(raw->entropy_collector);
+	raw->entropy_collector = NULL;
+	spin_unlock_bh(&raw->raw_lock);
+}
+
+/* seed or reseed the DRNG -- any locks necessary must be held by the caller */
+#define DRNG_RESET 1
+#define DRNG_RESEED 2
+static int jent_drng_update(struct jent_drng *drng, int type)
+{
+	/* since we are in atomic context with a lock taken, we
+	 * cannot kzalloc the memory */
+	char seed[100];
+	size_t seedsize = 0;
+	int ret = 0;
+
+	/*XXX remove the following once the ANSI X9.31 DRNG implementation
+	 * is updated */
+	type = DRNG_RESET;
+
+	if (DRNG_RESET == type)
+		seedsize = crypto_rng_seedsize(drng->drng);
+	else if (DRNG_RESEED == type)
+		seedsize = 16; /* there is no API to get that value but we know
+				  that the ANSI X9.31 V value is 16 bytes */
+
+	if (sizeof(seed) < seedsize || 0 > seedsize) {
+		printk(DRIVER_NAME": seedsize %zu reported by RNG is unexpected!\n", seedsize);
+		ret = -EFAULT;
+		goto out;
+	}
+
+	memset(&seed, 0, sizeof(seed));
+	if (0 > jent_read_entropy(drng->entropy_collector, seed, seedsize)) {
+		printk(DRIVER_NAME": Unable to obtain %zu bytes of entropy\n", seedsize);
+		ret = -EAGAIN;
+		goto out;
+	}
+
+	/* enable code only when kernel crypto API is extended with a
+	 * reseed interface -- in this case, remove the code marked
+	 * above!
+	 */
+#if 0
+	if (DRNG_RESEED == type)
+		ret = crypto_rng_reseed(drng->drng, seed, seedsize);
+	else
+#endif
+		ret = crypto_rng_reset(drng->drng, seed, seedsize);
+	if (ret)
+		printk(DRIVER_NAME": Failed to update rng\n");
+
+out:
+	return ret;
+}
+
+/* initialization of DRNG and reset of the DRNG:
+ * 1. allocation of the DRNG uses as frontend
+ * 2. allocation of entropy collector for seeding
+ */
+int jent_drng_init_drng(struct jent_drng *drng)
+{
+	int ret = 0;
+	char name[17];
+	struct crypto_rng *rng;
+
+	/* init DRNG */
+
+	/* if there are more DRNGs in the kernel in the future,
+	 * this can be made selectable via a module parameter.
+	 */
+	memset(&name, 0, sizeof(name));
+	if (fips_enabled)
+		sprintf(name, "fips(ansi_cprng)");
+	else
+		sprintf(name, "ansi_cprng");
+	rng = crypto_alloc_rng(name, 0, 0);
+	if (IS_ERR(rng)) {
+		printk(DRIVER_NAME": could not allocate RNG handle\n");
+		return -ENOMEM;
+	}
+
+	/* init entropy collector */
+	drng->entropy_collector = jent_entropy_collector_alloc(1, 0);
+	if (!drng->entropy_collector) {
+		crypto_free_rng(drng->drng);
+		drng->drng = NULL;
+		return -ENOMEM;
+	}
+
+	drng->drng = rng;
+	drng->norekey_data = 0;
+	drng->noreseed_data = 0;
+	jent_drng_stat_read_init(drng);
+	jent_drng_stat_reseed_init(drng);
+	jent_drng_stat_rekey_init(drng);
+
+	/* seed the new instance of the DRNG with the entropy collector */
+	ret = jent_drng_update(drng, DRNG_RESET);
+	if (ret)
+		jent_drng_cleanup_drng(drng);
+
+	/* initialize the spinlock last so that it can only be taken
+	 * after the memory allocation is successfully completed */
+	spin_lock_init(&drng->drng_lock);
+
+	return ret;
+}
+
+int jent_drng_init_raw(struct jent_raw *raw, unsigned int flags)
+{
+	int ret = 0;
+
+	raw->entropy_collector = jent_entropy_collector_alloc(1, flags);
+	if (!raw->entropy_collector)
+		ret = -ENOMEM;
+
+	/* we do not need the reseed/rekey values, and therefore do not
+	 * initialize them */
+	jent_drng_stat_read_init(raw);
+
+	/* initialize the spinlock last so that it can only be taken
+	 * after the memory allocation is successfully completed */
+	spin_lock_init(&raw->raw_lock);
+	return ret;
+}
+
+/* call this function with the limits and bytes set to 0 to force
+ * reseed of the seed and key
+ *
+ * return: the function returns the maximum bytes the caller is allowed to
+ * 	   pull from the RNG before another call to this function
+ * 	   is to be made
+ */
+size_t jent_drng_reseed_rekey(struct jent_drng *drng, const size_t lim_reseed,
+			      const size_t lim_rekey, size_t bytes)
+{
+	size_t max_bytes = 0;
+
+	if (drng->norekey_data >= lim_rekey) {
+		if (jent_drng_update(drng, DRNG_RESET))
+			return 0;
+		jent_drng_stat_rekey_add(drng, 1);
+		drng->norekey_data = 0;
+		drng->noreseed_data = 0;
+	}
+	/* if we did a full reset, a reseed is not needed */
+	else if (drng->noreseed_data >= lim_reseed) {
+		if (jent_drng_update(drng, DRNG_RESEED))
+			return 0;
+		jent_drng_stat_reseed_add(drng, 1);
+		drng->noreseed_data = 0;
+	}
+
+	/* calculate the bytes to be obtained in the next round of the RNG
+	 * to not overstep the limit boundaries */
+	max_bytes = min_t(size_t, (lim_rekey - drng->norekey_data),
+		       		  (lim_reseed - drng->noreseed_data));
+	/* of course, the maximum bytes cannot be higher than the bytes
+	 * requested */
+	max_bytes = min_t(size_t, max_bytes, bytes);
+
+	return max_bytes;
+}
+
+ssize_t jent_drng_get_bytes(struct jent_drng *drng, const size_t lim_reseed,
+			    const size_t lim_rekey, char *data, size_t len)
+{
+	int ret = 0;
+	size_t pull = 0;
+	char *p = data;
+	size_t orig_len = len;
+
+	while (0 < len) {
+		spin_lock_bh(&drng->drng_lock);
+		pull = jent_drng_reseed_rekey(drng, lim_reseed, lim_rekey, len);
+		if (!pull) {
+			spin_unlock_bh(&drng->drng_lock);
+			return -EFAULT;
+		}
+
+		ret = crypto_rng_get_bytes(drng->drng, p, pull);
+		if (0 >= ret) {
+			spin_unlock_bh(&drng->drng_lock);
+			printk(DRIVER_NAME": Unable to obtain %zu bytes from DRNG -- error code: %d\n", pull, ret);
+			return ret;
+		}
+		drng->noreseed_data += ret;
+		drng->norekey_data += ret;
+		jent_drng_stat_read_add(drng, ret);
+		spin_unlock_bh(&drng->drng_lock);
+
+		len -= ret;
+		p += ret;
+	}
+
+	return orig_len;
+}
+
+int jent_drng_get_bytes_raw(struct jent_raw *raw, char *data, size_t len)
+{
+	int ret = 0;
+
+	spin_lock_bh(&raw->raw_lock);
+	ret = jent_read_entropy(raw->entropy_collector, data, len);
+
+	if (0 > ret) {
+		printk(DRIVER_NAME": Unable to obtain %zu bytes of entropy\n", len);
+		ret = -EAGAIN;
+	}
+	else
+		jent_drng_stat_read_add(raw, ret);
+
+	spin_unlock_bh(&raw->raw_lock);
+	return ret;
+}
+
+/****************************************************************
+ * initialization of kernel module
+ ****************************************************************/
+
+static int __init jent_drng_init(void)
+{
+	int ret = 0;
+	int dbg = 0;
+	int kcapi = 0;
+
+	ret = jent_entropy_init();
+	if (ret) {
+		printk(DRIVER_NAME ": Initialization failed with host not compliant with requirements: %d\n", ret);
+		return -EFAULT;
+	}
+
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_DBG
+	ret = jent_dbg_init();
+	if (ret)
+		return ret;
+	dbg = 1;
+#endif
+
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_KCAPI
+	ret = jent_kcapi_init();
+	if (ret) {
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_DBG
+		/* uninitialize the DBG interface */
+		jent_dbg_exit();
+#endif /* CONFIG_CRYPTO_CPU_JITTERENTROPY_DBG */
+		return ret;
+	}
+	kcapi = 1;
+#endif /* CONFIG_CRYPTO_CPU_JITTERENTROPY_KCAPI */
+
+	printk(DRIVER_NAME ": Initialized and ready for operation with interfaces%s%s\n",
+			dbg	? " -DebugFS-" : "",
+			kcapi	? " -Kernel crypto API-" : ""
+	      );
+
+	return ret;
+}
+
+static void __exit jent_drng_exit(void)
+{
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_DBG
+	jent_dbg_exit();
+#endif
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_KCAPI
+	jent_kcapi_exit();
+#endif
+	printk(DRIVER_NAME ": Deconfigured and removed\n");
+}
+
+module_init(jent_drng_init);
+module_exit(jent_drng_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Stephan Mueller <smueller@chronox.de>");
+MODULE_DESCRIPTION("Non-physical True Random Number Generator based on CPU Jitter");
+
diff --git a/drivers/char/jitterentropy-drng.h b/drivers/char/jitterentropy-drng.h
new file mode 100644
index 0000000..8b53d2a
--- /dev/null
+++ b/drivers/char/jitterentropy-drng.h
@@ -0,0 +1,120 @@
+/*
+ * Non-physical true random number generator based on timing jitter.
+ *
+ * Copyright Stephan Mueller <smueller@chronox.de>, 2013
+ *
+ * License
+ * =======
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU General Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
+ * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+
+#ifndef _JITTERENTROPY_DRNG_KERNEL_H
+#define _JITTERENTROPY_DRNG_KERNEL_H
+
+/* Statistical data from the DRNG */
+struct jent_stat {
+	size_t read_data;	/* total data read from DRNG */
+	size_t num_reseed;	/* number of reseeds of DRNG since init */
+	size_t num_rekey;	/* number of rekeys of DRNG since init */
+};
+
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_DBG
+#define jent_drng_stat_read_add(rng, val)   rng->jent_stat.read_data += val
+#define jent_drng_stat_reseed_add(rng, val) rng->jent_stat.num_reseed += val
+#define jent_drng_stat_rekey_add(rng, val)  rng->jent_stat.num_rekey += val
+#define jent_drng_stat_read_init(rng)	    rng->jent_stat.read_data = 0
+#define jent_drng_stat_reseed_init(rng)	    rng->jent_stat.num_reseed = 0
+#define jent_drng_stat_rekey_init(rng)	    rng->jent_stat.num_rekey = 0
+#else /* CONFIG_CRYPTO_CPU_JITTERENTROPY_DBG */
+#define jent_drng_stat_read_add(rng, val)
+#define jent_drng_stat_reseed_add(rng, val)
+#define jent_drng_stat_rekey_add(rng, val)
+#define jent_drng_stat_read_init(rng)
+#define jent_drng_stat_reseed_init(rng)
+#define jent_drng_stat_rekey_init(rng)
+#endif /* CONFIG_CRYPTO_CPU_JITTERENTROPY_DBG */
+
+/* Entropy collector with DRNG as whitening function frontend */
+struct jent_drng
+{
+	spinlock_t drng_lock;
+	struct crypto_rng *drng; /* RNG handle */
+	struct rand_data *entropy_collector;	/* entropy collector */
+	size_t noreseed_data;   /* extracted data since last reseed */
+	size_t norekey_data;    /* extracted data since last re-key */
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_DBG
+	struct jent_stat jent_stat;
+#endif
+};
+
+/* Raw entropy collector */
+struct jent_raw
+{
+	spinlock_t raw_lock;
+	struct rand_data *entropy_collector;	/* entropy collector */
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_DBG
+	struct jent_stat jent_stat;
+#endif
+};
+
+/* --- BEGIN interfaces for the entropy collector connected to DRNG --- */
+int jent_drng_init_drng(struct jent_drng *drng);
+void jent_drng_cleanup_drng(struct jent_drng *drng);
+ssize_t jent_drng_get_bytes(struct jent_drng *drng, size_t lim_reseed,
+			    size_t lim_rekey, char *data, size_t len);
+size_t jent_drng_reseed_rekey(struct jent_drng *drng, size_t lim_reseed,
+			      size_t lim_rekey, size_t bytes);
+
+/* Reseed and rekey limits for regular DRNG */
+#define MAX_BYTES_RESEED 1<<10  /* max bytes before reseed */
+#define MAX_BYTES_REKEY  1<<20  /* max bytes before seed key is updated */
+
+/* Reseed and rekey limits for strong DRNG */
+#define MAX_BYTES_STRONG_RESEED 16	/* max bytes before reseed - note,
+					   this value is the size of the seed V
+					   and not crypto_rng_seedsize() since
+					   the function call returns the sum
+					   of V, DT, K -- and with a reseed
+					   we only update V */
+#define MAX_BYTES_STRONG_REKEY  1<<10 /* max bytes before update of seed key */
+/* --- END interfaces for the entropy collector connected DRNG --- */
+
+/* --- BEGIN interfaces for the raw entropy collector output --- */
+int jent_drng_init_raw(struct jent_raw *raw, unsigned int flags);
+void jent_drng_cleanup_raw(struct jent_raw *raw);
+int jent_drng_get_bytes_raw(struct jent_raw *raw, char *data, size_t len);
+/* --- END interfaces for the raw entropy collector output --- */
+
+
+#endif /* _JITTERENTROPY_DRNG_KERNEL_H */
diff --git a/drivers/char/jitterentropy-kcapi.c b/drivers/char/jitterentropy-kcapi.c
new file mode 100644
index 0000000..d81c930
--- /dev/null
+++ b/drivers/char/jitterentropy-kcapi.c
@@ -0,0 +1,174 @@
+/*
+ * Non-physical true random number generator based on timing jitter -- DRNG part
+ *
+ * Copyright Stephan Mueller <smueller@chronox.de>, 2013
+ *
+ * License
+ * =======
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU General Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
+ * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ */
+
+#include <linux/module.h>
+#include <crypto/internal/rng.h>
+
+#include "jitterentropy.h"
+#include "jitterentropy-drng.h"
+#include "jitterentropy-kcapi.h"
+
+/*************************************************************************
+ * Export DRNG instances to kernel crypto API
+ *************************************************************************/
+
+static int jent_kcapi_init_drng(struct crypto_tfm *tfm)
+{
+	return jent_drng_init_drng(crypto_tfm_ctx(tfm));
+}
+
+static void jent_kcapi_cleanup_drng(struct crypto_tfm *tfm)
+{
+	jent_drng_cleanup_drng(crypto_tfm_ctx(tfm));
+}
+
+static int jent_kcapi_reg_random(struct crypto_rng *tfm, u8 *rdata,
+			       unsigned int dlen)
+{
+	return jent_drng_get_bytes(crypto_rng_ctx(tfm),
+				   MAX_BYTES_RESEED, MAX_BYTES_REKEY,
+				   rdata, dlen);
+}
+
+static int jent_kcapi_strong_random(struct crypto_rng *tfm, u8 *rdata,
+				  unsigned int dlen)
+{
+	return jent_drng_get_bytes(crypto_rng_ctx(tfm),
+				   MAX_BYTES_STRONG_RESEED,
+				   MAX_BYTES_STRONG_REKEY,
+				   rdata, dlen);
+}
+
+static int jent_kcapi_reset_drng(struct crypto_rng *tfm, u8 *seed, unsigned int slen)
+{
+	return jent_drng_reseed_rekey(crypto_rng_ctx(tfm), 0, 0, 0);
+}
+
+/*************************************************************************
+ * Export raw entropy instance to kernel crypto API
+ *************************************************************************/
+static int jent_kcapi_init_raw(struct crypto_tfm *tfm)
+{
+	return jent_drng_init_raw(crypto_tfm_ctx(tfm), 0);
+}
+
+static void jent_kcapi_cleanup_raw(struct crypto_tfm *tfm)
+{
+	jent_drng_cleanup_raw(crypto_tfm_ctx(tfm));
+}
+
+static int jent_kcapi_raw_random(struct crypto_rng *tfm, u8 *rdata,
+			       unsigned int dlen)
+{
+	return jent_drng_get_bytes_raw(crypto_rng_ctx(tfm), rdata, dlen);
+}
+
+static int jent_kcapi_reset_raw(struct crypto_rng *tfm, u8 *seed, unsigned int slen)
+{
+	return 0;
+}
+
+/*************************************************************************
+ * Definitions of random number generators for kernel crypto API
+ *************************************************************************/
+static struct crypto_alg jent_drng_algs[] = { {
+	.cra_name               = "reg(jent_drng)",
+	.cra_driver_name        = "reg_jent_drng",
+	.cra_priority           = 100,
+	.cra_flags              = CRYPTO_ALG_TYPE_RNG,
+	.cra_ctxsize            = sizeof(struct jent_drng),
+	.cra_type               = &crypto_rng_type,
+	.cra_module             = THIS_MODULE,
+	.cra_init               = jent_kcapi_init_drng,
+	.cra_exit               = jent_kcapi_cleanup_drng,
+	.cra_u                  = {
+		.rng =	{
+			.rng_make_random	= jent_kcapi_reg_random,
+			.rng_reset		= jent_kcapi_reset_drng,
+			.seedsize		= 0,
+			}
+	}
+}, {
+	.cra_name               = "strong(jent_drng)",
+	.cra_driver_name        = "strong_jent_drng",
+	.cra_priority           = 300,
+	.cra_flags              = CRYPTO_ALG_TYPE_RNG,
+	.cra_ctxsize            = sizeof(struct jent_drng),
+	.cra_type               = &crypto_rng_type,
+	.cra_module             = THIS_MODULE,
+	.cra_init               = jent_kcapi_init_drng,
+	.cra_exit               = jent_kcapi_cleanup_drng,
+	.cra_u                  = {
+		.rng =	{
+			.rng_make_random	= jent_kcapi_strong_random,
+			.rng_reset		= jent_kcapi_reset_drng,
+			.seedsize		= 0,
+			}
+	}
+}, {
+	.cra_name               = "raw(jent_drng)",
+	.cra_driver_name        = "raw_jent_drng",
+	.cra_priority           = 300,
+	.cra_flags              = CRYPTO_ALG_TYPE_RNG,
+	.cra_ctxsize            = sizeof(struct jent_raw),
+	.cra_type               = &crypto_rng_type,
+	.cra_module             = THIS_MODULE,
+	.cra_init               = jent_kcapi_init_raw,
+	.cra_exit               = jent_kcapi_cleanup_raw,
+	.cra_u                  = {
+		.rng =	{
+			.rng_make_random	= jent_kcapi_raw_random,
+			.rng_reset		= jent_kcapi_reset_raw,
+			.seedsize		= 0,
+			}
+	}
+} };
+
+int __init jent_kcapi_init(void)
+{
+	return crypto_register_algs(jent_drng_algs, ARRAY_SIZE(jent_drng_algs));
+}
+
+void __exit jent_kcapi_exit(void)
+{
+	crypto_unregister_algs(jent_drng_algs, ARRAY_SIZE(jent_drng_algs));
+}
diff --git a/drivers/char/jitterentropy-kcapi.h b/drivers/char/jitterentropy-kcapi.h
new file mode 100644
index 0000000..af00131
--- /dev/null
+++ b/drivers/char/jitterentropy-kcapi.h
@@ -0,0 +1,50 @@
+/*
+ * Non-physical true random number generator based on timing jitter.
+ *
+ * Copyright Stephan Mueller <smueller@chronox.de>, 2013
+ *
+ * License
+ * =======
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU General Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
+ * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+
+#ifndef _JITTERENTROPY_KCAPI_KERNEL_H
+#define _JITTERENTROPY_KCAPI_KERNEL_H
+
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_KCAPI
+int __init jent_kcapi_init(void);
+void __exit jent_kcapi_exit(void);
+#endif
+
+#endif /* _JITTERENTROPY_KCAPI_KERNEL_H */
diff --git a/drivers/char/jitterentropy-stat.c b/drivers/char/jitterentropy-stat.c
new file mode 100644
index 0000000..a8d962a
--- /dev/null
+++ b/drivers/char/jitterentropy-stat.c
@@ -0,0 +1,133 @@
+/*
+ * Non-physical true random number generator based on timing jitter --
+ * Statistical calculations
+ *
+ * Copyright Stephan Mueller <smueller@chronox.de>, 2013
+ *
+ * License
+ * =======
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU General Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
+ * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ */
+
+#include "jitterentropy.h"
+
+/*********************************************************
+ * statistic gathering and validating functions
+ *********************************************************/
+
+void _jent_init_statistic(struct rand_data *rand_data)
+{
+	int i;
+	struct entropy_stat *stat = &rand_data->entropy_stat;
+
+	for(i = 0; i < 64; i++)
+	{
+		stat->bitslot[i] = 0;
+		stat->bitvar[i] = 0;
+	}
+
+	jent_get_nstime(&stat->collection_begin);
+}
+
+void _jent_bit_count(struct rand_data *rand_data, __u64 prev_data)
+{
+	int i;
+
+	if(!rand_data->entropy_stat.enable_bit_test)
+		return;
+
+	for(i = 0; i < 64; i++)
+	{
+		/* collect the count of set bits per bit position in the
+		 * current ->data field */
+		rand_data->entropy_stat.bitslot[i] += (rand_data->data & 1<<i) ? 1:0;
+
+		/* collect the count of bit changes between the current
+		 * and the previous random data value per bit position */
+		if ((rand_data->data & 1<<i) != (prev_data & 1<<i))
+			rand_data->entropy_stat.bitvar[i] += 1;
+	}
+}
+
+static void jent_statistic_copy_stat(struct entropy_stat *src,
+	       			     struct entropy_stat *dst)
+{
+	/* not copying bitslot and bitvar as they are not needed for statistic
+	 * printout */
+	dst->collection_begin 	= src->collection_begin;
+	dst->collection_end	= src->collection_end;
+	dst->old_delta		= src->old_delta;
+	dst->setbits		= src->setbits;
+	dst->varbits		= src->varbits;
+	dst->obsbits		= src->obsbits;
+	dst->collection_loop_cnt= src->collection_loop_cnt;
+}
+
+/*
+ * Assessment of statistical behavior of the generated output and returning
+ * the information to the caller by filling the target value.
+ *
+ * Details about the bit statistics are given in chapter 4 of the doc.
+ * Chapter 5 documents the timer analysis and the resulting entropy.
+ */
+void _jent_calc_statistic(struct rand_data *rand_data,
+			  struct entropy_stat *target, unsigned int loop_cnt)
+{
+	int i;
+	struct entropy_stat *stat = &rand_data->entropy_stat;
+
+	jent_get_nstime(&stat->collection_end);
+
+	stat->collection_loop_cnt = loop_cnt;
+
+	stat->setbits = 0;
+	stat->varbits = 0;
+	stat->obsbits = 0;
+
+	for(i = 0; i < DATA_SIZE_BITS; i++)
+	{
+		stat->setbits += stat->bitslot[i];
+		stat->varbits += stat->bitvar[i];
+
+		/* This is the sum of set bits in the current observation
+		 * of the random data. */
+		stat->obsbits += (rand_data->data & 1<<i) ? 1:0;
+	}
+
+	jent_statistic_copy_stat(stat, target);
+
+	stat->old_delta = (stat->collection_end - stat->collection_begin);
+}
+
diff --git a/drivers/char/jitterentropy.h b/drivers/char/jitterentropy.h
new file mode 100644
index 0000000..cd42055
--- /dev/null
+++ b/drivers/char/jitterentropy.h
@@ -0,0 +1,174 @@
+ï»¿/*
+ * Non-physical true random number generator based on timing jitter.
+ *
+ * Copyright Stephan Mueller <smueller@chronox.de>, 2014
+ *
+ * License
+ * =======
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU General Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
+ * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+
+#ifndef _JITTERENTROPY_H
+#define _JITTERENTROPY_H
+
+#ifdef __KERNEL__
+#include "jitterentropy-base-kernel.h"
+#else
+#include "jitterentropy-base-user.h"
+#endif /* __KERNEL__ */
+
+/* Statistical data from the entropy source */
+struct entropy_stat {
+	unsigned int bitslot[64];	/* Counter for the bits set per bit
+					   position in ->data */
+	unsigned int bitvar[64];	/* Counter for the number of bit
+					   variations per bit position in
+					   ->data */
+	unsigned int enable_bit_test;	/* enable bit test
+       					   this flag is vital for the accuracy
+					   of the statistic tests: when we
+					   do the time measurements, we want
+					   the observed entropy collection
+					   loop executed as fast as the
+					   unmeasured loop, i.e. without
+					   the bit statistic logic; on the
+					   other hand, the bit statistics
+					   test is not interested in exact
+					   timing */
+	__u64 collection_begin;		/* timer for beginning of one
+					   entropy collection round */
+	__u64 collection_end;		/* timer for end of one round */
+	__u64 old_delta;		/* Time delta of previous round to
+					   calculate delta of deltas */
+	unsigned int setbits;		/* see _jent_calc_statistic */
+	unsigned int varbits;		/* see _jent_calc_statistic */
+	unsigned int obsbits;		/* see _jent_calc_statistic */
+	unsigned int collection_loop_cnt;	/* Collection loop counter */
+};
+
+/* The entropy pool */
+struct rand_data
+{
+	/* all data values that are vital to maintain the security
+	 * of the RNG are marked as SENSITIVE. A user must not
+	 * access that information while the RNG executes its loops to
+	 * calculate the next random value. */
+	__u64 data;		/* SENSITIVE Actual random number */
+	__u64 prev_time;	/* SENSITIVE Previous time stamp */
+#define DATA_SIZE_BITS ((sizeof(__u64)) * 8)
+	__u64 old_data;		/* SENSITIVE FIPS continuous test */
+	unsigned int osr;	/* Oversample rate */
+	unsigned int fips_fail:1;	/* FIPS status */
+	unsigned int stir:1;		/* Post-processing stirring */
+	unsigned int disable_unbias:1;	/* Deactivate Von-Neuman unbias */
+#define JENT_MEMORY_BLOCKS 64
+#define JENT_MEMORY_BLOCKSIZE 32
+#define JENT_MEMORY_ACCESSLOOPS 128
+#define JENT_MEMORY_SIZE (JENT_MEMORY_BLOCKS*JENT_MEMORY_BLOCKSIZE)
+	unsigned char *mem;	/* Memory access location with size of
+				 * memblocks * memblocksize */
+	unsigned int memlocation; /* Pointer to byte in *mem */
+	unsigned int memblocks;	/* Number of memory blocks in *mem */
+	unsigned int memblocksize; /* Size of one memory block in bytes */
+	unsigned int memaccessloops; /* Number of memory accesses per random
+				      * bit generation */
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_STAT
+	struct entropy_stat entropy_stat;
+#endif
+};
+
+/* Flags that can be used to initialize the RNG */
+#define JENT_DISABLE_STIR (1<<0) /* Disable stirring the entropy pool */
+#define JENT_DISABLE_UNBIAS (1<<1) /* Disable Von Neuman unbias */
+#define JENT_DISABLE_MEMORY_ACCESS (1<<2) /* Disable memory access for more
+					     entropy, saves MEMORY_SIZE RAM for
+					     entropy collector */
+
+/* Number of low bits of the time value that we want to consider */
+#define TIME_ENTROPY_BITS 1
+
+#define DRIVER_NAME     "jitterentropy"
+
+/* -- BEGIN Main interface functions -- */
+
+/* Number of low bits of the time value that we want to consider */
+/* get raw entropy */
+int jent_read_entropy(struct rand_data *entropy_collector,
+		      char *data, size_t len);
+/* initialize an instance of the entropy collector */
+struct rand_data *jent_entropy_collector_alloc(unsigned int osr,
+	       				       unsigned int flags);
+/* clearing of entropy collector */
+void jent_entropy_collector_free(struct rand_data *entropy_collector);
+
+/* initialization of entropy collector */
+int jent_entropy_init(void);
+
+/* -- END of Main interface functions -- */
+
+/* -- BEGIN error codes for init function -- */
+#define ENOTIME  	1 /* Timer service not available */
+#define ECOARSETIME	2 /* Timer too coarse for RNG */
+#define ENOMONOTONIC	3 /* Timer is not monotonic increasing */
+#define EMINVARIATION	4 /* Timer variations too small for RNG */
+#define EVARVAR		5 /* Timer does not produce variations of variations
+			     (2nd derivation of time is zero) */
+#define EMINVARVAR	6 /* Timer variations of variations is too small */
+#define EPROGERR	7 /* Programming error */
+
+/* -- BEGIN statistical test functions only complied with CONFIG_CRYPTO_CPU_JITTERENTROPY_STAT -- */
+
+void _jent_init_statistic(struct rand_data *entropy_collector);
+void _jent_calc_statistic(struct rand_data *entropy_collector,
+			  struct entropy_stat *stat, unsigned int loop_cnt);
+void _jent_bit_count(struct rand_data *entropy_collector, __u64 prev_data);
+
+#ifdef CONFIG_CRYPTO_CPU_JITTERENTROPY_STAT
+#define jent_init_statistic(x)    do { _jent_init_statistic(x); }    while (0)
+#define jent_calc_statistic(x, y, z) do { _jent_calc_statistic(x, y, z); } while (0)
+#define jent_bit_count(x,y)       do { _jent_bit_count(x, y); }      while (0)
+void jent_gen_entropy_stat(struct rand_data *entropy_collector,
+			   struct entropy_stat *stat);
+void jent_fold_time_stat(struct rand_data *ec, __u64 *fold, __u64 *loop_cnt);
+__u64 jent_fold_var_stat(struct rand_data *ec, unsigned int min);
+__u64 jent_oscillation_var_stat(void);
+#else /* CONFIG_CRYPTO_CPU_JITTERENTROPY_STAT */
+#define jent_init_statistic(x)    do { if(0) _jent_init_statistic(x); }    while (0)
+#define jent_calc_statistic(x, y, z) do { if(0) _jent_calc_statistic(x, y, z); } while (0)
+#define jent_bit_count(x,y)       do { if(0) _jent_bit_count(x,y); }       while (0)
+#endif /* CONFIG_CRYPTO_CPU_JITTERENTROPY_STAT */
+
+/* -- END of statistical test function -- */
+
+#endif /* _JITTERENTROPY_H */
diff --git a/drivers/char/random.c b/drivers/char/random.c
index 71529e1..1735edf 100644
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -267,6 +267,8 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/random.h>
 
+#include "jitterentropy.h"
+
 /*
  * Configuration information
  */
@@ -430,19 +432,23 @@ struct entropy_store {
 	unsigned int limit:1;
 	unsigned int last_data_init:1;
 	__u8 last_data[EXTRACT_SIZE];
+	struct rand_data jent_ec;
 };
 
 static void push_to_pool(struct work_struct *work);
 static __u32 input_pool_data[INPUT_POOL_WORDS];
 static __u32 blocking_pool_data[OUTPUT_POOL_WORDS];
 static __u32 nonblocking_pool_data[OUTPUT_POOL_WORDS];
+static unsigned char input_jentmem[JENT_MEMORY_SIZE];
 
 static struct entropy_store input_pool = {
 	.poolinfo = &poolinfo_table[0],
 	.name = "input",
 	.limit = 1,
 	.lock = __SPIN_LOCK_UNLOCKED(input_pool.lock),
-	.pool = input_pool_data
+	.pool = input_pool_data,
+	.jent_ec.mem = input_jentmem,
+	.jent_ec.memblocks = 0,
 };
 
 static struct entropy_store blocking_pool = {
@@ -454,6 +460,7 @@ static struct entropy_store blocking_pool = {
 	.pool = blocking_pool_data,
 	.push_work = __WORK_INITIALIZER(blocking_pool.push_work,
 					push_to_pool),
+	.jent_ec.mem = NULL,
 };
 
 static struct entropy_store nonblocking_pool = {
@@ -464,6 +471,7 @@ static struct entropy_store nonblocking_pool = {
 	.pool = nonblocking_pool_data,
 	.push_work = __WORK_INITIALIZER(nonblocking_pool.push_work,
 					push_to_pool),
+	.jent_ec.mem = NULL,
 };
 
 static __u32 const twist_table[8] = {
@@ -715,6 +723,79 @@ static void credit_entropy_bits_safe(struct entropy_store *r, int nbits)
  *
  *********************************************************************/
 
+/* This function CANNOT be called from init_std_data to mix the pad further
+ * at initialization time, because the high-resolution clocksource drivers
+ * are loaded during module_init() time, just as init_std_data. Thus, there
+ * is no guarantee that the clocksource drivers are available for us.
+ */
+static void add_jent_randomness(struct entropy_store *r, int bytes)
+{
+#define JENT_BUFFER 64 /* ensure that JENT_BUFFER is a multiple of
+			* the CPU Jitter RNG block size */
+	char rand[JENT_BUFFER];
+	int ret = 0;
+	int entropy_count = 0;
+	unsigned long flags;
+
+	/* the initialization process determined that we cannot use the
+	 * CPU Jitter RNG or the caller provided wrong input */
+	if(NULL == r->jent_ec.mem || 0 >= bytes)
+		return;
+
+	/* only use the Jitter RNG if we fall to the low threshold as
+	 * otherwise the Jitter RNG monopolizes the noise sources */
+	entropy_count = ACCESS_ONCE(r->entropy_count);
+	entropy_count = entropy_count >> (ENTROPY_SHIFT);
+	if (entropy_count > random_read_wakeup_thresh)
+		return;
+
+	memset(rand, 0, JENT_BUFFER);
+	spin_lock_irqsave(&r->lock, flags);
+	if(0 == r->jent_ec.memblocks)
+	{
+		/* we are uninitialized, try to initialize */
+		if(jent_entropy_init())
+		{
+			/* there is no CPU Jitter, disable the collector */
+			r->jent_ec.mem = NULL;
+			spin_unlock_irqrestore(&r->lock, flags);
+			return;
+		}
+		r->jent_ec.data = 0;
+		r->jent_ec.prev_time = 0;
+		r->jent_ec.old_data = 0;
+		r->jent_ec.fips_fail = 0;
+		r->jent_ec.stir = 0;
+		r->jent_ec.disable_unbias = 0;
+		r->jent_ec.osr = 1;
+		/* r->jent_ec.mem does not need to be zeroized */
+		r->jent_ec.memblocksize = JENT_MEMORY_BLOCKSIZE;
+		r->jent_ec.memblocks = JENT_MEMORY_BLOCKS;
+		r->jent_ec.memaccessloops = JENT_MEMORY_ACCESSLOOPS;
+		/* fill the entropy collector and init the FIPS test
+		 * by pulling one round from the RNG */
+		jent_read_entropy(&r->jent_ec, rand, (DATA_SIZE_BITS / 8));
+	}
+
+	/* never pull more bytes than available in temp variable */
+	ret = min_t(int, bytes, JENT_BUFFER);
+#define JENT_WRAP (DATA_SIZE_BITS / 8 - 1)
+	/* round up number of bytes to be pulled to next multiple of
+	 * CPU Jitter RNG block size to be efficient */
+	ret = (ret + JENT_WRAP) &~ JENT_WRAP;
+
+	ret = jent_read_entropy(&r->jent_ec, rand, ret);
+	spin_unlock_irqrestore(&r->lock, flags);
+	if(0 < ret)
+	{
+		/* we do not need to worry about trickle threshold as we are
+		 * called when we are low on entropy */
+		mix_pool_bytes(r, rand, ret, NULL);
+		credit_entropy_bits(r, ret * 8);
+	}
+	memset(rand, 0, JENT_BUFFER);
+}
+
 /* There is one of these per entropy source */
 struct timer_rand_state {
 	cycles_t last_time;
@@ -951,6 +1032,7 @@ static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
 
 	trace_xfer_secondary_pool(r->name, bytes * 8, nbytes * 8,
 				  ENTROPY_BITS(r), ENTROPY_BITS(r->pull));
+	add_jent_randomness(r->pull, bytes);
 	bytes = extract_entropy(r->pull, tmp, bytes,
 				random_read_wakeup_bits / 8, rsvd_bytes);
 	mix_pool_bytes(r, tmp, bytes, NULL);
@@ -1663,6 +1745,34 @@ struct ctl_table random_table[] = {
 		.mode		= 0444,
 		.proc_handler	= proc_do_uuid,
 	},
+	{
+		.procname	= "jent_memblocksize",
+		.maxlen		= sizeof(int),
+		.mode		= 0444,
+		.proc_handler	= proc_dointvec,
+		.data		= &input_pool.jent_ec.memblocksize,
+	},
+	{
+		.procname	= "jent_memblocks",
+		.maxlen		= sizeof(int),
+		.mode		= 0444,
+		.proc_handler	= proc_dointvec,
+		.data		= &input_pool.jent_ec.memblocks,
+	},
+	{
+		.procname	= "jent_memaccessloops",
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+		.data		= &input_pool.jent_ec.memaccessloops,
+	},
+	{
+		.procname	= "jent_osr",
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+		.data		= &input_pool.jent_ec.osr,
+	},
 	{ }
 };
 #endif 	/* CONFIG_SYSCTL */
-- 
1.9.3

