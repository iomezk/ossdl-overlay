Index: misc/cgo/test/issue8331.h
===================================================================
new file mode 100644
--- /dev/null
+++ b/misc/cgo/test/issue8331.h
@@ -0,0 +1,7 @@
+// Copyright 2014 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+typedef struct {
+	int i;
+} issue8331;
Index: misc/cgo/test/issue8331a.go
===================================================================
new file mode 100644
--- /dev/null
+++ b/misc/cgo/test/issue8331a.go
@@ -0,0 +1,15 @@
+// Copyright 2014 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Issue 8331.  A typedef of an unnamed struct is the same struct when
+// #include'd twice.  No runtime test; just make sure it compiles.
+
+package cgotest
+
+// #include "issue8331.h"
+import "C"
+
+func issue8331a() C.issue8331 {
+	return issue8331Var
+}
Index: misc/cgo/test/issue8331b.go
===================================================================
new file mode 100644
--- /dev/null
+++ b/misc/cgo/test/issue8331b.go
@@ -0,0 +1,13 @@
+// Copyright 2014 The Go Authors.  All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Issue 8331.  A typedef of an unnamed struct is the same struct when
+// #include'd twice.  No runtime test; just make sure it compiles.
+
+package cgotest
+
+// #include "issue8331.h"
+import "C"
+
+var issue8331Var C.issue8331
Index: src/cmd/cgo/gcc.go
===================================================================
--- a/src/cmd/cgo/gcc.go
+++ b/src/cmd/cgo/gcc.go
@@ -1269,7 +1269,8 @@
 		sub := c.Type(dt.Type, pos)
 		t.Size = sub.Size
 		t.Align = sub.Align
-		if _, ok := typedef[name.Name]; !ok {
+		oldType := typedef[name.Name]
+		if oldType == nil {
 			tt := *t
 			tt.Go = sub.Go
 			typedef[name.Name] = &tt
@@ -1281,6 +1282,15 @@
 		// In -godefs and -cdefs mode, do this for all typedefs.
 		if isStructUnionClass(sub.Go) || *godefs || *cdefs {
 			t.Go = sub.Go
+
+			// If we've seen this typedef before, and it
+			// was an anonymous struct/union/class before
+			// too, use the old definition.
+			// TODO: it would be safer to only do this if
+			// we verify that the types are the same.
+			if oldType != nil && isStructUnionClass(oldType.Go) {
+				t.Go = oldType.Go
+			}
 		}
 
 	case *dwarf.UcharType:
